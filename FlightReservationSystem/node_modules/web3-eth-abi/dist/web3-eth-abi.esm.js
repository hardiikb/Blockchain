import * as Utils from 'web3-utils';
import { AbiCoder } from 'ethers/utils/abi-coder';
import isArray from 'lodash/isArray';
import isObject from 'lodash/isObject';

class AbiCoder$1 {
  constructor(utils, ethersAbiCoder) {
    this.utils = utils;
    this.ethersAbiCoder = ethersAbiCoder;
  }
  encodeFunctionSignature(functionName) {
    if (isObject(functionName)) {
      functionName = this.utils.jsonInterfaceMethodToString(functionName);
    }
    return this.utils.sha3(functionName).slice(0, 10);
  }
  encodeEventSignature(functionName) {
    if (isObject(functionName)) {
      functionName = this.utils.jsonInterfaceMethodToString(functionName);
    }
    return this.utils.sha3(functionName);
  }
  encodeParameter(type, param) {
    return this.encodeParameters([type], [param]);
  }
  encodeParameters(types, params) {
    return this.ethersAbiCoder.encode(types, params);
  }
  encodeFunctionCall(jsonInterface, params) {
    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');
  }
  decodeParameter(type, bytes) {
    return this.decodeParameters([type], bytes)[0];
  }
  decodeParameters(outputs, bytes) {
    if (isArray(outputs) && outputs.length === 0) {
      throw new Error('Empty outputs array given!');
    }
    if (!bytes || bytes === '0x' || bytes === '0X') {
      throw new Error(`Invalid bytes string given: ${bytes}`);
    }
    const result = this.ethersAbiCoder.decode(outputs, bytes);
    let returnValues = {};
    if (outputs.length > 1) {
      let decodedValue;
      outputs.forEach((output, i) => {
        decodedValue = result[i];
        if (decodedValue === '0x') {
          decodedValue = null;
        }
        returnValues[i] = decodedValue;
        if (isObject(output) && output.name) {
          returnValues[output.name] = decodedValue;
        }
      });
      return returnValues;
    }
    returnValues = {
      0: result
    };
    returnValues[outputs[0].name] = result;
    return returnValues;
  }
  decodeLog(inputs, data = '', topics) {
    const returnValues = {};
    let topicCount = 0;
    let value;
    let nonIndexedInputKeys = [];
    if (!isArray(topics)) {
      topics = [topics];
    }
    inputs.forEach((input, i) => {
      if (input.indexed) {
        value = topics[topicCount];
        if (this.isStaticType(input.type)) {
          value = this.decodeParameter(input, topics[topicCount]);
        }
        if (input.type === 'string') {
          return;
        }
        returnValues[i] = value;
        returnValues[input.name] = value;
        topicCount++;
        return;
      }
      nonIndexedInputKeys.push({
        key: i,
        input: input
      });
    });
    if (data) {
      nonIndexedInputKeys.forEach(item => {
        value = this.decodeParameter(item.input, data);
        returnValues[item.key] = value;
        returnValues[item.input.name] = value;
      });
    }
    return returnValues;
  }
  isStaticType(type) {
    if (type === 'bytes') {
      return false;
    }
    if (type === 'string') {
      return false;
    }
    if (type.indexOf('[') && type.slice(type.indexOf('[')).length === 2) {
      return false;
    }
    return true;
  }
}

const AbiCoder$2 = () => {
  return new AbiCoder$1(Utils,
  new AbiCoder((type, value) => {
    if (type.match(/^u?int/) && !isArray(value) && !isObject(value) || value.constructor.name !== 'BigNumber') {
      return value.toString();
    }
    return value;
  }));
};

export { AbiCoder$2 as AbiCoder };
